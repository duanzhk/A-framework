{"code":"import { ObjectUtil, StringUtil } from \"../utils\";\r\nexport class Broadcaster {\r\n    constructor() {\r\n        this._persistBrodcastMap = {};\r\n        this._listenerHandlerMap = {};\r\n        this._stickBrodcastMap = {};\r\n        this._unuseHandlers = [];\r\n    }\r\n    /**\r\n     * 回收handler\r\n     * @param handler\r\n     */\r\n    _recoverHandler(handler) {\r\n        if (!handler)\r\n            return;\r\n        //@ts-ignore\r\n        handler.listener = undefined;\r\n        handler.key = undefined;\r\n        handler.args = undefined;\r\n        handler.context = undefined;\r\n        this._unuseHandlers.push(handler);\r\n    }\r\n    //检查是否有有效的监听器，如果没有就删除这个key\r\n    _checkListenerValidity(key) {\r\n        if (!key)\r\n            return;\r\n        const handlers = this._listenerHandlerMap[key];\r\n        if (handlers && handlers.length > 0) {\r\n            return;\r\n        }\r\n        delete this._listenerHandlerMap[key];\r\n    }\r\n    /**\r\n     * 添加广播监听，如果有粘性广播就会执行粘性广播\r\n     * @param handler\r\n     */\r\n    _addHandler(handler) {\r\n        const handlerMap = this._listenerHandlerMap;\r\n        const msgKey = handler.key;\r\n        const handlers = handlerMap[msgKey] || [];\r\n        handlers.push(handler);\r\n        handlerMap[msgKey] = handlers;\r\n        //检查是否有粘性广播\r\n        const stickyHandlers = this._stickBrodcastMap[msgKey];\r\n        if (stickyHandlers) {\r\n            //需要把执行过的粘性广播删除，防止注册时再次执行\r\n            this.removeStickyBroadcast(msgKey);\r\n            for (let i = 0; i < stickyHandlers.length; i++) {\r\n                let e = stickyHandlers[i];\r\n                this.dispatch(msgKey, e.data, e.callback, e.persistence);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 将广播的数据作为参数，执行广播监听器的逻辑\r\n     * @param handler 广播监听器\r\n     * @param data 广播携带的数据\r\n     * @param callback 回调函数\r\n     */\r\n    _runHandler(handler, data, callback) {\r\n        if (!handler.listener)\r\n            return;\r\n        let args = [];\r\n        if (data) {\r\n            args.push(data);\r\n        }\r\n        if (callback) {\r\n            data.push(callback);\r\n        }\r\n        //如果有透传参数，则添加到参数列表中\r\n        if (handler.args && handler.args.length > 0) {\r\n            args.push(...handler.args);\r\n        }\r\n        return handler.listener.apply(handler.context, args);\r\n        ;\r\n    }\r\n    _onHander(keyOrHandler, listener, context, once, args) {\r\n        if (typeof keyOrHandler === \"string\") {\r\n            if (!listener)\r\n                return;\r\n            let handlerObj = this._unuseHandlers.pop() || {};\r\n            handlerObj.key = keyOrHandler;\r\n            handlerObj.listener = listener;\r\n            handlerObj.context = context;\r\n            handlerObj.once = once;\r\n            handlerObj.args = args;\r\n            this._addHandler(handlerObj);\r\n        }\r\n        else {\r\n            if (ObjectUtil.isArray(keyOrHandler)) {\r\n                const handlers = keyOrHandler;\r\n                for (let i = 0; i < handlers.length; i++) {\r\n                    this._addHandler(handlers[i]);\r\n                }\r\n            }\r\n            else {\r\n                this._addHandler(keyOrHandler);\r\n            }\r\n        }\r\n    }\r\n    on(keyOrHandler, listener, context, args) {\r\n        this._onHander(keyOrHandler, listener, context, false, args);\r\n    }\r\n    once(keyOrHandler, listener, context, args) {\r\n        this._onHander(keyOrHandler, listener, context, true, args);\r\n    }\r\n    /**\r\n     * 注销指定监听\r\n     * @param key 事件名\r\n     * @param listener 监听回调\r\n     * @return this\r\n     */\r\n    off(key, listener) {\r\n        let handlers = this._listenerHandlerMap[key];\r\n        if (!handlers) {\r\n            throw new Error(`没有找到key为${key.toString()}的事件`);\r\n        }\r\n        const index = handlers.findIndex((handler) => handler.listener === listener);\r\n        const handler = handlers.fastRemoveAt(index);\r\n        this._recoverHandler(handler);\r\n        this._checkListenerValidity(key);\r\n        return this;\r\n    }\r\n    offAll(key, context) {\r\n        const handlerMap = this._listenerHandlerMap;\r\n        //指定key或全局清除\r\n        const processHandler = (handlers, msgKey, hasContext) => {\r\n            for (let i = handlers.length - 1; i >= 0; i--) {\r\n                const shouldRemove = !hasContext || handlers[i].context === context;\r\n                shouldRemove && this._recoverHandler(handlers.fastRemoveAt(i));\r\n            }\r\n            this._checkListenerValidity(msgKey);\r\n        };\r\n        if (key) { //清除指定key的所有监听\r\n            if (!handlerMap[key]) {\r\n                throw new Error(`没有找到key为${key.toString()}的事件`);\r\n            }\r\n            processHandler(handlerMap[key], key, false);\r\n        }\r\n        else { //处理全局或上下文清除\r\n            const isGlobalClear = !context;\r\n            Object.keys(handlerMap).forEach((msgKey) => {\r\n                const k = msgKey;\r\n                processHandler(handlerMap[k], k, !isGlobalClear);\r\n            });\r\n            isGlobalClear && (this._listenerHandlerMap = {});\r\n        }\r\n    }\r\n    /**\r\n     * 广播\r\n     *\r\n     * @param key 消息类型\r\n     * @param data 消息携带的数据\r\n     * @param callback\r\n     * @param persistence 是否持久化消息类型。持久化的消息可以在任意时刻通过 getPersistentValue(key) 获取最后一次被持久化的数据。\r\n     */\r\n    dispatch(key, data, callback, persistence) {\r\n        if (StringUtil.isEmptyOrWhiteSpace(key.toString())) {\r\n            throw new Error('广播的key不能为空');\r\n        }\r\n        //持久化\r\n        persistence !== null && persistence !== void 0 ? persistence : (this._persistBrodcastMap[key] = data);\r\n        const handlers = this._listenerHandlerMap[key];\r\n        if (!handlers || handlers.length == 0) {\r\n            console.warn(`没有注册广播：${key.toString()}`);\r\n            return;\r\n        }\r\n        ;\r\n        for (let i = handlers.length - 1; i >= 0; i--) {\r\n            let handler = handlers[i];\r\n            this._runHandler(handler, data, callback);\r\n            if (handler.once) {\r\n                this.off(key, handler.listener);\r\n            }\r\n        }\r\n        this._checkListenerValidity(key);\r\n    }\r\n    /**\r\n     * 广播一条粘性消息。如果广播系统中没有注册该类型的接收者，本条信息将被滞留在系统中，否则等效dispatch方法。\r\n     * 可以使用removeStickyBroadcast移除存在的粘性广播。\r\n     *\r\n     * @param key 消息类型\r\n     * @param data 消息携带的数据\r\n     * @param callback\r\n     * @param persistence 是否持久化消息类型。持久化的消息可以在任意时刻通过 getPersistentValue(key) 获取最后一次被持久化的数据。\r\n     */\r\n    dispatchSticky(key, data, callback, persistence) {\r\n        var _a;\r\n        var _b;\r\n        if (StringUtil.isEmptyOrWhiteSpace(key.toString())) {\r\n            throw new Error('广播的key不能为空');\r\n        }\r\n        //如果已经有了监听者，则直接广播\r\n        if (this._listenerHandlerMap[key]) {\r\n            this.dispatch(key, data, callback, persistence);\r\n            return;\r\n        }\r\n        //注意：??= 在ES2021(TypeScript版本4.4)引入\r\n        ((_a = (_b = this._stickBrodcastMap)[key]) !== null && _a !== void 0 ? _a : (_b[key] = [])).push({\r\n            key: key,\r\n            data: data,\r\n            callback: callback,\r\n            persistence: persistence\r\n        });\r\n        //如果persistence=true需要先持久化，不能等到通过on->broadcast的时候再持久化。\r\n        //因为中途可能会有removeStickyBroadcast操作，那么on就不会调用broadcast，造成持久化无效bug。\r\n        persistence !== null && persistence !== void 0 ? persistence : (this._persistBrodcastMap[key] = data);\r\n    }\r\n    /**\r\n     * 移除指定的粘性广播\r\n     *\r\n     * @param key\r\n     */\r\n    removeStickyBroadcast(key) {\r\n        if (this._stickBrodcastMap[key]) {\r\n            delete this._stickBrodcastMap[key];\r\n        }\r\n    }\r\n    /**\r\n     * 事件注册是否被注册\r\n     * @param key\r\n     */\r\n    isRegistered(key) {\r\n        return !!this._listenerHandlerMap[key];\r\n    }\r\n    /**\r\n     * 获取被持久化的消息。ps:相同key的持久化广播会被覆盖。\r\n     * @param key\r\n     */\r\n    getPersistentValue(key) {\r\n        return this._persistBrodcastMap[key];\r\n    }\r\n    /**\r\n    * 销毁广播系统\r\n    */\r\n    dispose() {\r\n        //@ts-ignore\r\n        this._listenerHandlerMap = undefined;\r\n        //@ts-ignore\r\n        this._stickBrodcastMap = undefined;\r\n        //@ts-ignore\r\n        this._persistBrodcastMap = undefined;\r\n    }\r\n}\r\n","references":["/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/src/core/index.ts","/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/src/utils/index.ts"],"dts":{"name":"/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/node_modules/.cache/rollup-plugin-typescript2/placeholder/libs/Broadcaster.d.ts","writeByteOrderMark":false,"text":"import { ListenerHandler, ToAnyIndexKey, OnListenerResult, IEventManager, OnListener, IEventMsgKey } from \"../core\";\r\nexport declare class Broadcaster<MsgKeyType extends IEventMsgKey, ValueType = any, ResultType = any> implements IEventManager<MsgKeyType, ValueType, ResultType> {\r\n    private _persistBrodcastMap;\r\n    private _listenerHandlerMap;\r\n    private _stickBrodcastMap;\r\n    private _unuseHandlers;\r\n    constructor();\r\n    /**\r\n     * 回收handler\r\n     * @param handler\r\n     */\r\n    private _recoverHandler;\r\n    private _checkListenerValidity;\r\n    /**\r\n     * 添加广播监听，如果有粘性广播就会执行粘性广播\r\n     * @param handler\r\n     */\r\n    private _addHandler;\r\n    /**\r\n     * 将广播的数据作为参数，执行广播监听器的逻辑\r\n     * @param handler 广播监听器\r\n     * @param data 广播携带的数据\r\n     * @param callback 回调函数\r\n     */\r\n    private _runHandler;\r\n    private _onHander;\r\n    /**\r\n     * 注册事件\r\n     * @param key 事件名\r\n     * @param listener 监听回调\r\n     * @param context 上下文\r\n     * @param args 透传参数\r\n     *\r\n     */\r\n    on<keyType extends keyof MsgKeyType>(key: keyType, listener: OnListener<ValueType[ToAnyIndexKey<keyType, ValueType>], ResultType[ToAnyIndexKey<keyType, ResultType>]>, context?: any, args?: any[]): void;\r\n    on<keyType extends keyof MsgKeyType>(handler: ListenerHandler<keyType, ValueType, ResultType> | ListenerHandler<keyType, ValueType, ResultType>[]): void;\r\n    /**\r\n     * 注册事件，只监听一次\r\n     * @param key 事件名\r\n     * @param listener 监听回调\r\n     * @param context 上下文\r\n     * @param args 透传参数\r\n     *\r\n     */\r\n    once<keyType extends keyof MsgKeyType>(key: keyType, listener: OnListener<ValueType[ToAnyIndexKey<keyType, ValueType>], ResultType[ToAnyIndexKey<keyType, ResultType>]>, context?: any, args?: any[]): void;\r\n    once<keyType extends keyof MsgKeyType>(handler: ListenerHandler<keyType, ValueType, ResultType> | ListenerHandler<keyType, ValueType, ResultType>[]): void;\r\n    /**\r\n     * 注销指定监听\r\n     * @param key 事件名\r\n     * @param listener 监听回调\r\n     * @return this\r\n     */\r\n    off<keyType extends keyof MsgKeyType>(key: keyType, listener: OnListener<ValueType[ToAnyIndexKey<keyType, ValueType>], ResultType[ToAnyIndexKey<keyType, ResultType>]>): this;\r\n    /**\r\n     * 注销所有监听\r\n     * @param key\r\n     * @param context\r\n     */\r\n    offAll(): void;\r\n    offAll<keyType extends keyof MsgKeyType>(key: keyType): void;\r\n    offAll(context: any): void;\r\n    /**\r\n     * 广播\r\n     *\r\n     * @param key 消息类型\r\n     * @param data 消息携带的数据\r\n     * @param callback\r\n     * @param persistence 是否持久化消息类型。持久化的消息可以在任意时刻通过 getPersistentValue(key) 获取最后一次被持久化的数据。\r\n     */\r\n    dispatch<keyType extends keyof MsgKeyType>(key: keyType, data?: ValueType[ToAnyIndexKey<keyType, ValueType>], callback?: OnListenerResult<ResultType[ToAnyIndexKey<keyType, ResultType>]>, persistence?: boolean): void;\r\n    /**\r\n     * 广播一条粘性消息。如果广播系统中没有注册该类型的接收者，本条信息将被滞留在系统中，否则等效dispatch方法。\r\n     * 可以使用removeStickyBroadcast移除存在的粘性广播。\r\n     *\r\n     * @param key 消息类型\r\n     * @param data 消息携带的数据\r\n     * @param callback\r\n     * @param persistence 是否持久化消息类型。持久化的消息可以在任意时刻通过 getPersistentValue(key) 获取最后一次被持久化的数据。\r\n     */\r\n    dispatchSticky<keyType extends keyof MsgKeyType>(key: keyType, data?: ValueType[ToAnyIndexKey<keyType, ValueType>], callback?: OnListenerResult<ResultType[ToAnyIndexKey<keyType, ResultType>]>, persistence?: boolean): void;\r\n    /**\r\n     * 移除指定的粘性广播\r\n     *\r\n     * @param key\r\n     */\r\n    removeStickyBroadcast(key: keyof MsgKeyType): void;\r\n    /**\r\n     * 事件注册是否被注册\r\n     * @param key\r\n     */\r\n    isRegistered(key: keyof MsgKeyType): boolean;\r\n    /**\r\n     * 获取被持久化的消息。ps:相同key的持久化广播会被覆盖。\r\n     * @param key\r\n     */\r\n    getPersistentValue<keyType extends keyof MsgKeyType>(key: keyType): ValueType[ToAnyIndexKey<keyType, ValueType>] | undefined;\r\n    /**\r\n    * 销毁广播系统\r\n    */\r\n    dispose(): void;\r\n}\r\n"}}
