{"code":"import { ServiceLocator } from \".\";\r\n// 通过symbol实现接口标识\r\nconst interfaceSymbols = new Map();\r\n// 装饰器，方便自动注册manager和model\r\nconst modelRegistry = [];\r\nconst managerRegistry = [];\r\nexport function getInterface(ctor) {\r\n    let sym = interfaceSymbols.get(ctor);\r\n    if (!sym)\r\n        throw new Error(`Manager ${ctor.name} not registered! Please use @manager() decorator to register it.`);\r\n    return sym;\r\n}\r\nfunction manager() {\r\n    return function (ctor) {\r\n        // 自动生成并注册Symbol\r\n        if (!interfaceSymbols.has(ctor)) {\r\n            interfaceSymbols.set(ctor, Symbol(ctor.name));\r\n        }\r\n        managerRegistry.push(ctor);\r\n    };\r\n}\r\nexport function model() {\r\n    return function (ctor) {\r\n        modelRegistry.push(ctor);\r\n    };\r\n}\r\nexport function autoRegister(core) {\r\n    modelRegistry.forEach(ctor => {\r\n        console.log(`${ctor.name} initialize`);\r\n        core.regModel(new ctor());\r\n    });\r\n    managerRegistry.forEach(ctor => {\r\n        console.log(`${ctor.name} initialize`);\r\n        core.regManager(new ctor());\r\n    });\r\n}\r\n// 依赖注入\r\n// ------------------------------------------------------------------------------------\r\nconst INJECTED_PROPERTIES_KEY = 'injectedProperties';\r\n// 因为明文定义的属性会覆盖injectManager（通过defineProperty定义）注入的属性，所以需要在编译时删除明文定义的属性\r\nfunction CleanInjectedProperties(constructor) {\r\n    return class extends constructor {\r\n        constructor(...args) {\r\n            super(...args);\r\n            // 递归收集当前类及其所有父类的注入属性\r\n            const collectInjectedProperties = (klass) => {\r\n                if (klass === null || klass === Object)\r\n                    return [];\r\n                const parentProperties = collectInjectedProperties(Object.getPrototypeOf(klass));\r\n                const currentProperties = Reflect.getMetadata(INJECTED_PROPERTIES_KEY, klass) || [];\r\n                // const currentProperties :any[] = []\r\n                return [...parentProperties, ...currentProperties];\r\n            };\r\n            // 合并并去重属性名\r\n            const injectedProperties = [\r\n                ...new Set(collectInjectedProperties(constructor))\r\n            ];\r\n            // 删除实例上的所有注入属性\r\n            injectedProperties.forEach(prop => {\r\n                if (this.hasOwnProperty(prop)) {\r\n                    delete this[prop];\r\n                }\r\n            });\r\n        }\r\n    };\r\n}\r\nexport function managedWithClean() {\r\n    return function (ctor) {\r\n        // 先执行清理逻辑\r\n        const decoratedCtor = CleanInjectedProperties(ctor);\r\n        // 后执行注册逻辑\r\n        manager()(decoratedCtor);\r\n        return decoratedCtor;\r\n    };\r\n}\r\n// 懒加载依赖注入manager\r\nexport function injectManager(sym) {\r\n    return function (target, prop) {\r\n        const injectionKey = Symbol.for(prop);\r\n        Object.defineProperty(target, prop, {\r\n            get: function () {\r\n                console.log(`[属性访问] 触发getter：${injectionKey.toString()}`);\r\n                if (!this[injectionKey]) {\r\n                    this[injectionKey] = ServiceLocator.getService('core').getManager(sym);\r\n                }\r\n                return this[injectionKey];\r\n            },\r\n            set: function (val) {\r\n                throw new Error('InjectManager property is read-only');\r\n            },\r\n            enumerable: true,\r\n            configurable: false // 禁止修改属性描述符\r\n        });\r\n        // 2. 将属性名记录到元数据\r\n        const injectedProperties = Reflect.getMetadata(INJECTED_PROPERTIES_KEY, target.constructor) || [];\r\n        if (!injectedProperties.includes(prop)) {\r\n            injectedProperties.push(prop);\r\n        }\r\n        Reflect.defineMetadata(INJECTED_PROPERTIES_KEY, injectedProperties, target.constructor);\r\n    };\r\n}\r\n","references":["/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/src/core/index.ts"],"dts":{"name":"/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/node_modules/.cache/rollup-plugin-typescript2/placeholder/core/Decorators.d.ts","writeByteOrderMark":false,"text":"import { ICore, IManager } from \".\";\r\nexport declare function getInterface<T extends Function>(ctor: T): symbol;\r\nexport declare function model(): (ctor: Function) => void;\r\nexport declare function autoRegister(core: ICore): void;\r\nexport declare function managedWithClean(): (ctor: Function) => any;\r\nexport declare function injectManager(sym: symbol): (target: IManager, prop: string) => void;\r\n"}}
