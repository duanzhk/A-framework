{"code":"// @ts-ignore\r\n!Array.prototype.__cc_extended && Object.defineProperties(Array.prototype, {\r\n    remove: {\r\n        value: function (filter) {\r\n            if (typeof (filter) == 'function') {\r\n                for (let i = this.length - 1; i > -1; --i) {\r\n                    filter(this[i], i, this) && this.splice(i, 1);\r\n                }\r\n            }\r\n            else {\r\n                for (let i = this.length - 1; i > -1; --i) {\r\n                    this[i] === filter && this.splice(i, 1);\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    },\r\n    removeOne: {\r\n        value: function (filter) {\r\n            if (typeof (filter) == 'function') {\r\n                for (let i = 0; i < this.length; ++i) {\r\n                    if (filter(this[i], i, this)) {\r\n                        this.splice(i, 1);\r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (let i = 0; i < this.length; ++i) {\r\n                    if (this[i] === filter) {\r\n                        this.splice(i, 1);\r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n    },\r\n    random: {\r\n        value: function () {\r\n            let element = this[Math.floor(Math.random() * this.length)];\r\n            return element;\r\n        }\r\n    },\r\n    fastRemoveAt: {\r\n        value: function (index) {\r\n            const length = this.length;\r\n            if (index < 0 || index >= length) {\r\n                return null;\r\n            }\r\n            let res = this[index];\r\n            this[index] = this[length - 1];\r\n            this.length = length - 1;\r\n            return res;\r\n        }\r\n    },\r\n    fastRemove: {\r\n        value: function (value) {\r\n            const index = this.indexOf(value);\r\n            if (index >= 0) {\r\n                this[index] = this[this.length - 1];\r\n                --this.length;\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    first: {\r\n        value: function () {\r\n            return this.length ? this[0] : null;\r\n        }\r\n    },\r\n    last: {\r\n        value: function () {\r\n            return this.length ? this[this.length - 1] : null;\r\n        }\r\n    },\r\n    max: {\r\n        value: function (mapper) {\r\n            if (!this.length) {\r\n                return null;\r\n            }\r\n            function _max(a, b) {\r\n                return a > b ? a : b;\r\n            }\r\n            if (typeof (mapper) == 'function') {\r\n                let max = mapper(this[0], 0, this);\r\n                for (let i = 1; i < this.length; ++i) {\r\n                    let temp = mapper(this[i], i, this);\r\n                    max = temp > max ? temp : max;\r\n                }\r\n                return max;\r\n            }\r\n            else {\r\n                return this.reduce(function (prev, cur) { return _max(prev, cur); });\r\n            }\r\n        }\r\n    },\r\n    min: {\r\n        value: function (mapper) {\r\n            if (!this.length) {\r\n                return null;\r\n            }\r\n            function _min(a, b) {\r\n                return a < b ? a : b;\r\n            }\r\n            if (typeof (mapper) == 'function') {\r\n                let min = mapper(this[0], 0, this);\r\n                for (let i = 1; i < this.length; ++i) {\r\n                    let temp = mapper(this[i], i, this);\r\n                    min = temp < min ? temp : min;\r\n                }\r\n                return min;\r\n            }\r\n            else {\r\n                return this.reduce(function (prev, cur) { return _min(prev, cur); });\r\n            }\r\n        }\r\n    },\r\n    distinct: {\r\n        value: function () {\r\n            return this.filter(function (v, i, arr) { return arr.indexOf(v) === i; });\r\n        }\r\n    },\r\n    filterIndex: {\r\n        value: function (filter) {\r\n            let output = [];\r\n            for (let i = 0; i < this.length; ++i) {\r\n                if (filter(this[i], i, this)) {\r\n                    output.push(i);\r\n                }\r\n            }\r\n            return output;\r\n        }\r\n    },\r\n    count: {\r\n        value: function (filter) {\r\n            let result = 0;\r\n            for (let i = 0; i < this.length; ++i) {\r\n                if (filter(this[i], i, this)) {\r\n                    ++result;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    },\r\n    sum: {\r\n        value: function (mapper) {\r\n            let result = 0;\r\n            for (let i = 0; i < this.length; ++i) {\r\n                result += mapper ? mapper(this[i], i, this) : this[i];\r\n            }\r\n            return result;\r\n        }\r\n    },\r\n    average: {\r\n        value: function (mapper) {\r\n            return this.sum(mapper) / this.length;\r\n        }\r\n    },\r\n    orderBy: {\r\n        value: function () {\r\n            let mappers = [];\r\n            for (let _i = 0; _i < arguments.length; _i++) {\r\n                mappers[_i] = arguments[_i];\r\n            }\r\n            return this.slice().sort(function (a, b) {\r\n                for (let i = 0; i < mappers.length; ++i) {\r\n                    let va = mappers[i](a);\r\n                    let vb = mappers[i](b);\r\n                    if (va > vb) {\r\n                        return 1;\r\n                    }\r\n                    else if (va < vb) {\r\n                        return -1;\r\n                    }\r\n                }\r\n                return 0;\r\n            });\r\n        }\r\n    },\r\n    orderByDesc: {\r\n        value: function () {\r\n            let mappers = [];\r\n            for (let _i = 0; _i < arguments.length; _i++) {\r\n                mappers[_i] = arguments[_i];\r\n            }\r\n            return this.slice().sort(function (a, b) {\r\n                for (let i = 0; i < mappers.length; ++i) {\r\n                    let va = mappers[i](a);\r\n                    let vb = mappers[i](b);\r\n                    if (va > vb) {\r\n                        return -1;\r\n                    }\r\n                    else if (va < vb) {\r\n                        return 1;\r\n                    }\r\n                }\r\n                return 0;\r\n            });\r\n        }\r\n    },\r\n    binarySearch: {\r\n        value: function (value, keyMapper) {\r\n            let low = 0, high = this.length - 1;\r\n            while (low <= high) {\r\n                let mid = ((high + low) / 2) | 0;\r\n                let midValue = keyMapper ? keyMapper(this[mid]) : this[mid];\r\n                if (value === midValue) {\r\n                    return mid;\r\n                }\r\n                else if (value > midValue) {\r\n                    low = mid + 1;\r\n                }\r\n                else if (value < midValue) {\r\n                    high = mid - 1;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    },\r\n    binaryInsert: {\r\n        value: function (item, keyMapper, unique) {\r\n            if (typeof (keyMapper) == 'boolean') {\r\n                unique = keyMapper;\r\n                keyMapper = undefined;\r\n            }\r\n            let low = 0, high = this.length - 1;\r\n            let mid = NaN;\r\n            let itemValue = keyMapper ? keyMapper(item) : item;\r\n            while (low <= high) {\r\n                mid = ((high + low) / 2) | 0;\r\n                let midValue = keyMapper ? keyMapper(this[mid]) : this[mid];\r\n                if (itemValue === midValue) {\r\n                    if (unique) {\r\n                        return mid;\r\n                    }\r\n                    else {\r\n                        break;\r\n                    }\r\n                }\r\n                else if (itemValue > midValue) {\r\n                    low = mid + 1;\r\n                }\r\n                else if (itemValue < midValue) {\r\n                    high = mid - 1;\r\n                }\r\n            }\r\n            let index = low > mid ? mid + 1 : mid;\r\n            this.splice(index, 0, item);\r\n            return index;\r\n        }\r\n    },\r\n    binaryDistinct: {\r\n        value: function (keyMapper) {\r\n            return this.filter(function (v, i, arr) { return arr.binarySearch(v, keyMapper) === i; });\r\n        }\r\n    },\r\n    findLast: {\r\n        value: function (predicate) {\r\n            for (let i = this.length - 1; i > -1; --i) {\r\n                if (predicate(this[i], i, this)) {\r\n                    return this[i];\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n    },\r\n    findLastIndex: {\r\n        value: function (predicate) {\r\n            for (let i = this.length - 1; i > -1; --i) {\r\n                if (predicate(this[i], i, this)) {\r\n                    return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    },\r\n    groupBy: {\r\n        value: function (grouper) {\r\n            let group = this.reduce(function (prev, next) {\r\n                let groupKey = grouper(next);\r\n                if (!prev[groupKey]) {\r\n                    prev[groupKey] = [];\r\n                }\r\n                prev[groupKey].push(next);\r\n                return prev;\r\n            }, {});\r\n            return Object.keys(group).map(function (key) {\r\n                let arr = group[key];\r\n                arr.key = key;\r\n                return arr;\r\n            });\r\n        }\r\n    },\r\n    __cc_extended: {\r\n        value: true\r\n    }\r\n});\r\nexport {};\r\n","references":[],"dts":{"name":"/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/node_modules/.cache/rollup-plugin-typescript2/placeholder/utils/ArrayExt.d.ts","writeByteOrderMark":false,"text":"declare global {\r\n    interface Array<T> {\r\n        remove(filter: (v: T, i: number, arr: Array<T>) => boolean): Array<T>;\r\n        remove(filter: T): Array<T>;\r\n        removeOne(filter: (v: T, i: number, arr: Array<T>) => boolean): Array<T>;\r\n        removeOne(filter: T): Array<T>;\r\n        random(): T;\r\n        first(): T;\r\n        last(): T;\r\n        max(): T;\r\n        max<P>(mapper: (v: T, i: number, arr: this) => P): P | null;\r\n        min(): T;\r\n        min<P>(mapper: (v: T, i: number, arr: this) => P): P | null;\r\n        distinct(): Array<T>;\r\n        filterIndex(filter: (v: T, i: number, arr: this) => boolean): Array<number>;\r\n        count(filter: (v: T, i: number, arr: this) => boolean): number;\r\n        sum(mapper?: (v: T, i: number, arr: this) => number): number;\r\n        average(mapper?: (v: T, i: number, arr: this) => number): number;\r\n        /**\r\n         * 移除指定位置的元素。注意：会改变数组顺序，原理是将最后一个元素填充到指定位置\r\n         * @param index\r\n         * @return 返回被移除的元素\r\n         */\r\n        fastRemoveAt(index: number): T;\r\n        /**\r\n         * 移除指定的元素。注意：会改变数组顺序，原理是将最后一个元素填充到指定位置\r\n         * @param value\r\n         * @return 返回是否移除成功\r\n         */\r\n        fastRemove(value: T): boolean;\r\n        /**\r\n         * 同find，但返回整个Array<T>中最后一个匹配元素\r\n         */\r\n        findLast(predicate: (value: T, index: number, obj: Array<T>) => boolean): T | undefined;\r\n        /**\r\n         * 同find，但返回整个Array<T>中最后一个匹配元素的index\r\n         */\r\n        findLastIndex(predicate: (value: T, index: number, obj: Array<T>) => boolean): number;\r\n        orderBy(...mappers: ((v: T) => any)[]): Array<T>;\r\n        orderByDesc(...mappers: ((v: T) => any)[]): Array<T>;\r\n        /**\r\n         * 二分查找 前提是数组一定是有序的\r\n         * @param value 要查找的值\r\n         * @param keyMapper 要查找的值的mapper方法（默认为查找数组元素本身）\r\n         * @return 查找到的index，查不到返回-1\r\n         */\r\n        binarySearch(value: number | string, keyMapper?: (v: T) => (number | string)): number;\r\n        /**\r\n         * 二分插入 前提是数组一定是有序的\r\n         * @param item 要插入的值\r\n         * @param keyMapper 二分查找时要查找的值的mapper方法（默认为查找数组元素本身）\r\n         * @param unique 是否去重，如果为true，则如果数组内已经有值时不插入，返回已有值的number\r\n         * @return 返回插入的index位置\r\n         */\r\n        binaryInsert(item: T, unique?: boolean): number;\r\n        binaryInsert(item: T, keyMapper: (v: T) => (number | string), unique?: boolean): number;\r\n        /**\r\n         * 二分去重 前提是数组一定是有序的\r\n         * @param keyMapper 二分查找时要查找的值的mapper方法（默认为查找数组元素本身）\r\n         */\r\n        binaryDistinct(keyMapper?: (v: T) => (number | string)): Array<T>;\r\n        groupBy(grouper: (v: T) => any): (T[] & {\r\n            key: any;\r\n        })[];\r\n    }\r\n}\r\nexport {};\r\n"}}
