{"code":"import { Mat4, Vec3 } from \"cc\";\r\n/** 数学工具 */\r\nexport class MathUtil {\r\n    /**\r\n     * 获得随机方向\r\n     * @param x -1为左，1为右\r\n     * @returns\r\n     */\r\n    static sign(x) {\r\n        if (x > 0) {\r\n            return 1;\r\n        }\r\n        if (x < 0) {\r\n            return -1;\r\n        }\r\n        return 0;\r\n    }\r\n    /**\r\n     * 随时间变化进度值\r\n     * @param start 初始值\r\n     * @param end   结束值\r\n     * @param t     时间\r\n     */\r\n    static progress(start, end, t) {\r\n        return start + (end - start) * t;\r\n    }\r\n    /**\r\n     * 插值\r\n     * @param numStart 开始数值\r\n     * @param numEnd   结束数值\r\n     * @param t        时间\r\n     */\r\n    static lerp(numStart, numEnd, t) {\r\n        if (t > 1) {\r\n            t = 1;\r\n        }\r\n        else if (t < 0) {\r\n            t = 0;\r\n        }\r\n        return numStart * (1 - t) + (numEnd * t);\r\n    }\r\n    /**\r\n     * 角度插值\r\n     * @param angle1 角度1\r\n     * @param angle2 角度2\r\n     * @param t      时间\r\n     */\r\n    static lerpAngle(current, target, t) {\r\n        current %= 360;\r\n        target %= 360;\r\n        var dAngle = target - current;\r\n        if (dAngle > 180) {\r\n            target = current - (360 - dAngle);\r\n        }\r\n        else if (dAngle < -180) {\r\n            target = current + (360 + dAngle);\r\n        }\r\n        return (MathUtil.lerp(current, target, t) % 360 + 360) % 360;\r\n    }\r\n    /**\r\n     * 按一定的速度从一个角度转向令一个角度\r\n     * @param current 当前角度\r\n     * @param target  目标角度\r\n     * @param speed   速度\r\n     */\r\n    static angleTowards(current, target, speed) {\r\n        current %= 360;\r\n        target %= 360;\r\n        var dAngle = target - current;\r\n        if (dAngle > 180) {\r\n            target = current - (360 - dAngle);\r\n        }\r\n        else if (dAngle < -180) {\r\n            target = current + (360 + dAngle);\r\n        }\r\n        var dir = target - current;\r\n        if (speed > Math.abs(dir)) {\r\n            return target;\r\n        }\r\n        return ((current + speed * Math.sign(dir)) % 360 + 360) % 360;\r\n    }\r\n    /**\r\n     * 获取方位内值，超过时获取对应边界值\r\n     * @param value     值\r\n     * @param minLimit  最小值\r\n     * @param maxLimit  最大值\r\n     */\r\n    static clamp(value, minLimit, maxLimit) {\r\n        if (value < minLimit) {\r\n            return minLimit;\r\n        }\r\n        if (value > maxLimit) {\r\n            return maxLimit;\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * 获得一个值的概率\r\n     * @param value 值\r\n     */\r\n    static probability(value) {\r\n        return Math.random() < value;\r\n    }\r\n    /**\r\n     * 整数随机\r\n     * @param min\r\n     * @param max\r\n     * @returns\r\n     */\r\n    static randomInt(min, max) {\r\n        min = Math.ceil(min);\r\n        max = Math.floor(max);\r\n        return Math.floor(Math.random() * (max - min + 1)) + min;\r\n    }\r\n    /**\r\n     * 随机算法, 均匀分布法\r\n     * @param rangeStart\r\n     * @param rangeEnd\r\n     * @param count\r\n     * @returns\r\n     */\r\n    static generateUniformNumbers(rangeStart, rangeEnd, count, sort) {\r\n        const rangeSize = rangeEnd - rangeStart;\r\n        const step = Math.floor(rangeSize / (count - 1));\r\n        // Uniform distribution method\r\n        let uniformNumbers = [];\r\n        for (let i = 0; i < count; i++) {\r\n            let v = rangeStart + i * step + Math.random();\r\n            uniformNumbers.push(v);\r\n        }\r\n        if (sort)\r\n            uniformNumbers.sort((a, b) => a - b);\r\n        return uniformNumbers;\r\n    }\r\n    /**\r\n     * 随机算法，黄金分割法\r\n     * @param rangeStart\r\n     * @param rangeEnd\r\n     * @param count\r\n     * @returns\r\n     */\r\n    static generateGoldenNumbers(rangeStart, rangeEnd, count) {\r\n        if (count > rangeEnd - rangeStart + 1) {\r\n            throw new Error(\"Count cannot be larger than the size of the range.\");\r\n        }\r\n        const rangeSize = rangeEnd - rangeStart;\r\n        // Golden ratio method\r\n        const goldenRatio = (Math.sqrt(5) - 1) / 2;\r\n        let goldenNumbers = [];\r\n        for (let i = 0; i < count; i++) {\r\n            let v = rangeStart + (goldenRatio * i) % rangeSize;\r\n            goldenNumbers.push(v);\r\n        }\r\n        goldenNumbers.sort((a, b) => a - b);\r\n        return goldenNumbers;\r\n    }\r\n    static calculateDistance(point1, point2) {\r\n        const deltaX = point2.x - point1.x;\r\n        const deltaY = point2.y - point1.y;\r\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n    }\r\n    /**\r\n     * 随时间变化进度值\r\n     * @param start  起始位置\r\n     * @param end    结束位置\r\n     * @param t      进度[0，1]\r\n     */\r\n    static progressV3(start, end, t) {\r\n        var current = new Vec3();\r\n        current.x = MathUtil.progress(start.x, end.x, t);\r\n        current.y = MathUtil.progress(start.y, end.y, t);\r\n        current.z = MathUtil.progress(start.z, end.z, t);\r\n        return current;\r\n    }\r\n    /**\r\n     * 求两个三维向量的和\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static add(pos1, pos2) {\r\n        var outPos = new Vec3();\r\n        Vec3.add(outPos, pos1, pos2);\r\n        return outPos;\r\n    }\r\n    /**\r\n     * 求两个三维向量的差\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static subV3(pos1, pos2) {\r\n        var outPos = new Vec3();\r\n        Vec3.subtract(outPos, pos1, pos2);\r\n        return outPos;\r\n    }\r\n    /**\r\n     * 三维向量乘以常量\r\n     * @param pos     向量\r\n     * @param scalar  常量\r\n     */\r\n    static mul(pos, scalar) {\r\n        var outPos = new Vec3();\r\n        Vec3.multiplyScalar(outPos, pos, scalar);\r\n        return outPos;\r\n    }\r\n    /**\r\n     * 三维向量除常量\r\n     * @param pos     向量\r\n     * @param scalar  常量\r\n     */\r\n    static div(pos, scalar) {\r\n        var outPos = new Vec3();\r\n        outPos.x = pos.x / scalar;\r\n        outPos.y = pos.y / scalar;\r\n        outPos.z = pos.z / scalar;\r\n        return outPos;\r\n    }\r\n    /**\r\n     * 判断两个三维向量的值是否相等\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static equals(pos1, pos2) {\r\n        if (pos1.x == pos2.x && pos1.y == pos2.y && pos1.z == pos2.z) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * 三维向量的模\r\n     * @param pos  向量\r\n     */\r\n    static magnitude(pos) {\r\n        return pos.length();\r\n    }\r\n    /**\r\n     * 三维向量归一化\r\n     * @param pos  向量\r\n     */\r\n    static normalize(pos) {\r\n        var outPos = new Vec3(pos.x, pos.y, pos.z);\r\n        return outPos.normalize();\r\n    }\r\n    /**\r\n     * 获得位置1，到位置2的方向\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static direction(pos1, pos2) {\r\n        var outPos = new Vec3();\r\n        Vec3.subtract(outPos, pos2, pos1);\r\n        return outPos.normalize();\r\n    }\r\n    /**\r\n     * 获得两点间的距离\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static distance(pos1, pos2) {\r\n        return Vec3.distance(pos1, pos2);\r\n    }\r\n    /**\r\n     * 插值运算\r\n     * @param posStart  开始俏步\r\n     * @param posEnd    结束位置\r\n     * @param t         时间\r\n     */\r\n    static lerpV3(posStart, posEnd, t) {\r\n        return MathUtil.bezierOne(t, posStart, posEnd);\r\n    }\r\n    /**\r\n     * 球面插值\r\n     * @param from  起点\r\n     * @param to    终点\r\n     * @param t     时间\r\n     */\r\n    static slerp(from, to, t) {\r\n        if (t <= 0) {\r\n            return from;\r\n        }\r\n        else if (t >= 1) {\r\n            return to;\r\n        }\r\n        var dir = MathUtil.rotateTo(from, to, (Vec3.angle(from, to) / Math.PI * 180) * t);\r\n        var lenght = to.length() * t + from.length() * (1 - t);\r\n        return (dir.normalize()).multiplyScalar(lenght);\r\n    }\r\n    /**\r\n     * 向量旋转一个角度\r\n     * @param from  起点\r\n     * @param to    终点\r\n     * @param angle 角并\r\n     */\r\n    static rotateTo(from, to, angle) {\r\n        //如果两个方向角度为0，则返回目标\r\n        if (Vec3.angle(from, to) == 0) {\r\n            return to;\r\n        }\r\n        var axis = new Vec3(); // 获得旋转轴\r\n        Vec3.cross(axis, from, to);\r\n        axis.normalize();\r\n        var radian = angle * Math.PI / 180; // 获得弧度\r\n        var rotateMatrix = new Mat4();\r\n        rotateMatrix.rotate(radian, axis);\r\n        return new Vec3(from.x * rotateMatrix.m00 + from.y * rotateMatrix.m04 + from.z * rotateMatrix.m08, from.x * rotateMatrix.m01 + from.y * rotateMatrix.m05 + from.z * rotateMatrix.m09, from.x * rotateMatrix.m02 + from.y * rotateMatrix.m06 + from.z * rotateMatrix.m10);\r\n    }\r\n    /**\r\n     * 一次贝塞尔即为线性插值函数\r\n     * @param t\r\n     * @param posStart\r\n     * @param posEnd\r\n     * @returns\r\n     */\r\n    static bezierOne(t, posStart, posEnd) {\r\n        if (t > 1) {\r\n            t = 1;\r\n        }\r\n        else if (t < 0) {\r\n            t = 0;\r\n        }\r\n        var pStart = posStart.clone();\r\n        var pEnd = posEnd.clone();\r\n        return pStart.multiplyScalar(1 - t).add(pEnd.multiplyScalar(t));\r\n    }\r\n    /**\r\n     * 二次贝塞尔曲线\r\n     * @param t\r\n     * @param posStart\r\n     * @param posCon\r\n     * @param posEnd\r\n     * @returns\r\n     */\r\n    static bezierTwo(t, posStart, posCon, posEnd) {\r\n        if (t > 1) {\r\n            t = 1;\r\n        }\r\n        else if (t < 0) {\r\n            t = 0;\r\n        }\r\n        var n = (1 - t);\r\n        var tt = t * t;\r\n        var pStart = posStart.clone();\r\n        var pos = new Vec3();\r\n        var pCon = posCon.clone();\r\n        var pEnd = posEnd.clone();\r\n        pos.add(pStart.multiplyScalar(n * n));\r\n        pos.add(pCon.multiplyScalar(2 * n * t));\r\n        pos.add(pEnd.multiplyScalar(tt));\r\n        return pos;\r\n    }\r\n    /**\r\n     * 三次贝塞尔\r\n     * @param t\r\n     * @param posStart\r\n     * @param posCon1\r\n     * @param posCon2\r\n     * @param posEnd\r\n     * @returns\r\n     */\r\n    static bezierThree(t, posStart, posCon1, posCon2, posEnd) {\r\n        if (t > 1) {\r\n            t = 1;\r\n        }\r\n        else if (t < 0) {\r\n            t = 0;\r\n        }\r\n        var n = (1 - t);\r\n        var nn = n * n;\r\n        var nnn = nn * n;\r\n        var tt = t * t;\r\n        var ttt = tt * t;\r\n        var pStart = posStart.clone();\r\n        var pos = posStart.clone();\r\n        var pCon1 = posCon1.clone();\r\n        var pCon2 = posCon2.clone();\r\n        var pEnd = posEnd.clone();\r\n        pos.add(pStart.multiplyScalar(nnn));\r\n        pos.add(pCon1.multiplyScalar(3 * nn * t));\r\n        pos.add(pCon2.multiplyScalar(3 * n * tt));\r\n        pos.add(pEnd.multiplyScalar(ttt));\r\n        return pos;\r\n    }\r\n    /**\r\n     * 点乘\r\n     * @param dir1 方向量1\r\n     * @param dir2 方向量2\r\n     */\r\n    static dot(dir1, dir2) {\r\n        var tempDir1 = dir1;\r\n        var tempDir2 = dir2;\r\n        return tempDir1.x * tempDir2.x + tempDir1.y * tempDir2.y + tempDir1.z * tempDir2.z;\r\n    }\r\n    /**\r\n     * 叉乘\r\n     * @param dir1 方向量1\r\n     * @param dir2 方向量2\r\n     */\r\n    static cross(dir1, dir2) {\r\n        var i = new Vec3(1, 0, 0);\r\n        var j = new Vec3(0, 1, 0);\r\n        var k = new Vec3(0, 0, 1);\r\n        var tempDir1 = new Vec3(dir1.x, dir1.y, dir1.z);\r\n        var tempDir2 = new Vec3(dir2.x, dir2.y, dir2.z);\r\n        var iv = i.multiplyScalar(tempDir1.y * tempDir2.z - tempDir2.y * tempDir1.z);\r\n        var jv = j.multiplyScalar(tempDir2.x * tempDir1.z - tempDir1.x * tempDir2.z);\r\n        var kv = k.multiplyScalar(tempDir1.x * tempDir2.y - tempDir2.x * tempDir1.y);\r\n        return iv.add(jv).add(kv);\r\n    }\r\n    /**\r\n     * 获得两个方向向量的角度\r\n     * @param dir1 方向量1\r\n     * @param dir2 方向量2\r\n     */\r\n    static angle(dir1, dir2) {\r\n        var dotValue = MathUtil.dot(dir1.clone().normalize(), dir2.clone().normalize());\r\n        return Math.acos(dotValue) / Math.PI * 180 * Math.sign(dotValue);\r\n    }\r\n    /**\r\n     * 获得方向a到方向b的角度（带有方向的角度）\r\n     * @param a 角度a\r\n     * @param b 角度b\r\n     */\r\n    static dirAngle(a, b) {\r\n        var c = MathUtil.cross(a, b);\r\n        var angle = MathUtil.angle(a, b);\r\n        // a 到 b 的夹角\r\n        var sign = Math.sign(MathUtil.dot(c.normalize(), MathUtil.cross(b.normalize(), a.normalize())));\r\n        return angle * sign;\r\n    }\r\n}\r\n/**\r\n * 角度转弧度\r\n */\r\nMathUtil.deg2Rad = Math.PI / 180;\r\n/**\r\n * 弧度转角度\r\n */\r\nMathUtil.rad2Deg = 180 / Math.PI;\r\n","references":[],"dts":{"name":"/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/node_modules/.cache/rollup-plugin-typescript2/placeholder/utils/MathUtil.d.ts","writeByteOrderMark":false,"text":"import { Vec2, Vec3 } from \"cc\";\r\n/** 数学工具 */\r\nexport declare class MathUtil {\r\n    /**\r\n     * 角度转弧度\r\n     */\r\n    static readonly deg2Rad: number;\r\n    /**\r\n     * 弧度转角度\r\n     */\r\n    static readonly rad2Deg: number;\r\n    /**\r\n     * 获得随机方向\r\n     * @param x -1为左，1为右\r\n     * @returns\r\n     */\r\n    static sign(x: number): 0 | 1 | -1;\r\n    /**\r\n     * 随时间变化进度值\r\n     * @param start 初始值\r\n     * @param end   结束值\r\n     * @param t     时间\r\n     */\r\n    static progress(start: number, end: number, t: number): number;\r\n    /**\r\n     * 插值\r\n     * @param numStart 开始数值\r\n     * @param numEnd   结束数值\r\n     * @param t        时间\r\n     */\r\n    static lerp(numStart: number, numEnd: number, t: number): number;\r\n    /**\r\n     * 角度插值\r\n     * @param angle1 角度1\r\n     * @param angle2 角度2\r\n     * @param t      时间\r\n     */\r\n    static lerpAngle(current: number, target: number, t: number): number;\r\n    /**\r\n     * 按一定的速度从一个角度转向令一个角度\r\n     * @param current 当前角度\r\n     * @param target  目标角度\r\n     * @param speed   速度\r\n     */\r\n    static angleTowards(current: number, target: number, speed: number): number;\r\n    /**\r\n     * 获取方位内值，超过时获取对应边界值\r\n     * @param value     值\r\n     * @param minLimit  最小值\r\n     * @param maxLimit  最大值\r\n     */\r\n    static clamp(value: number, minLimit: number, maxLimit: number): number;\r\n    /**\r\n     * 获得一个值的概率\r\n     * @param value 值\r\n     */\r\n    static probability(value: number): boolean;\r\n    /**\r\n     * 整数随机\r\n     * @param min\r\n     * @param max\r\n     * @returns\r\n     */\r\n    static randomInt(min: number, max: number): number;\r\n    /**\r\n     * 随机算法, 均匀分布法\r\n     * @param rangeStart\r\n     * @param rangeEnd\r\n     * @param count\r\n     * @returns\r\n     */\r\n    static generateUniformNumbers(rangeStart: number, rangeEnd: number, count: number, sort?: boolean): number[];\r\n    /**\r\n     * 随机算法，黄金分割法\r\n     * @param rangeStart\r\n     * @param rangeEnd\r\n     * @param count\r\n     * @returns\r\n     */\r\n    static generateGoldenNumbers(rangeStart: number, rangeEnd: number, count: number): number[];\r\n    static calculateDistance(point1: Vec2, point2: Vec2): number;\r\n    /**\r\n     * 随时间变化进度值\r\n     * @param start  起始位置\r\n     * @param end    结束位置\r\n     * @param t      进度[0，1]\r\n     */\r\n    static progressV3(start: Vec3, end: Vec3, t: number): Vec3;\r\n    /**\r\n     * 求两个三维向量的和\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static add(pos1: Vec3, pos2: Vec3): Vec3;\r\n    /**\r\n     * 求两个三维向量的差\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static subV3(pos1: Vec3, pos2: Vec3): Vec3;\r\n    /**\r\n     * 三维向量乘以常量\r\n     * @param pos     向量\r\n     * @param scalar  常量\r\n     */\r\n    static mul(pos: Vec3, scalar: number): Vec3;\r\n    /**\r\n     * 三维向量除常量\r\n     * @param pos     向量\r\n     * @param scalar  常量\r\n     */\r\n    static div(pos: Vec3, scalar: number): Vec3;\r\n    /**\r\n     * 判断两个三维向量的值是否相等\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static equals(pos1: Vec3, pos2: Vec3): boolean;\r\n    /**\r\n     * 三维向量的模\r\n     * @param pos  向量\r\n     */\r\n    static magnitude(pos: Vec3): number;\r\n    /**\r\n     * 三维向量归一化\r\n     * @param pos  向量\r\n     */\r\n    static normalize(pos: Vec3): Vec3;\r\n    /**\r\n     * 获得位置1，到位置2的方向\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static direction(pos1: Vec3, pos2: Vec3): Vec3;\r\n    /**\r\n     * 获得两点间的距离\r\n     * @param pos1  向量1\r\n     * @param pos2  向量2\r\n     */\r\n    static distance(pos1: Vec3, pos2: Vec3): number;\r\n    /**\r\n     * 插值运算\r\n     * @param posStart  开始俏步\r\n     * @param posEnd    结束位置\r\n     * @param t         时间\r\n     */\r\n    static lerpV3(posStart: Vec3, posEnd: Vec3, t: number): Vec3;\r\n    /**\r\n     * 球面插值\r\n     * @param from  起点\r\n     * @param to    终点\r\n     * @param t     时间\r\n     */\r\n    static slerp(from: Vec3, to: Vec3, t: number): Vec3;\r\n    /**\r\n     * 向量旋转一个角度\r\n     * @param from  起点\r\n     * @param to    终点\r\n     * @param angle 角并\r\n     */\r\n    static rotateTo(from: Vec3, to: Vec3, angle: number): Vec3;\r\n    /**\r\n     * 一次贝塞尔即为线性插值函数\r\n     * @param t\r\n     * @param posStart\r\n     * @param posEnd\r\n     * @returns\r\n     */\r\n    static bezierOne(t: number, posStart: Vec3, posEnd: Vec3): Vec3;\r\n    /**\r\n     * 二次贝塞尔曲线\r\n     * @param t\r\n     * @param posStart\r\n     * @param posCon\r\n     * @param posEnd\r\n     * @returns\r\n     */\r\n    static bezierTwo(t: number, posStart: Vec3, posCon: Vec3, posEnd: Vec3): Vec3;\r\n    /**\r\n     * 三次贝塞尔\r\n     * @param t\r\n     * @param posStart\r\n     * @param posCon1\r\n     * @param posCon2\r\n     * @param posEnd\r\n     * @returns\r\n     */\r\n    static bezierThree(t: number, posStart: Vec3, posCon1: Vec3, posCon2: Vec3, posEnd: Vec3): Vec3;\r\n    /**\r\n     * 点乘\r\n     * @param dir1 方向量1\r\n     * @param dir2 方向量2\r\n     */\r\n    static dot(dir1: Vec3, dir2: Vec3): number;\r\n    /**\r\n     * 叉乘\r\n     * @param dir1 方向量1\r\n     * @param dir2 方向量2\r\n     */\r\n    static cross(dir1: Vec3, dir2: Vec3): Vec3;\r\n    /**\r\n     * 获得两个方向向量的角度\r\n     * @param dir1 方向量1\r\n     * @param dir2 方向量2\r\n     */\r\n    static angle(dir1: Vec3, dir2: Vec3): number;\r\n    /**\r\n     * 获得方向a到方向b的角度（带有方向的角度）\r\n     * @param a 角度a\r\n     * @param b 角度b\r\n     */\r\n    static dirAngle(a: Vec3, b: Vec3): number;\r\n}\r\n"}}
