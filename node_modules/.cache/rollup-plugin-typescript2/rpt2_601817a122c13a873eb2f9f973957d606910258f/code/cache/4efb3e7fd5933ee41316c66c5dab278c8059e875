{"code":"import { __awaiter } from \"tslib\";\r\nimport { director, input, instantiate, Node, Input, Widget, Sprite } from \"cc\";\r\nimport { ServiceLocator } from \"@mflow/api\";\r\nfunction addWidget(node) {\r\n    const widget = node.getComponent(Widget) || node.addComponent(Widget);\r\n    widget.isAlignLeft = widget.isAlignRight = widget.isAlignTop = widget.isAlignBottom = true;\r\n    widget.left = widget.right = widget.top = widget.bottom = 0;\r\n}\r\nlet _uiRoot;\r\nconst UIRoot = new Proxy({}, {\r\n    get(target, prop) {\r\n        if (!_uiRoot) {\r\n            const canvas = director.getScene().getChildByPath('Canvas');\r\n            director.addPersistRootNode(canvas);\r\n            _uiRoot = new Node('__UIRoot__');\r\n            _uiRoot.layer = canvas.layer;\r\n            _uiRoot.setParent(canvas);\r\n            addWidget(_uiRoot);\r\n        }\r\n        return Reflect.get(_uiRoot, prop);\r\n    }\r\n});\r\nfunction setLayer(node) {\r\n    node.layer = UIRoot.layer;\r\n    node.children.forEach(child => {\r\n        setLayer(child);\r\n    });\r\n}\r\nfunction addChild(node) {\r\n    UIRoot.addChild(node);\r\n    setLayer(node);\r\n}\r\nlet _uiMask;\r\nconst UIMask = new Proxy({}, {\r\n    get(target, prop) {\r\n        if (!_uiMask) {\r\n            _uiMask = new Node('__UIMask__');\r\n            addChild(_uiMask);\r\n            addWidget(_uiMask);\r\n            _uiMask.setPosition(0, 0);\r\n            _uiMask.addComponent(Sprite).color.set(0, 0, 0, 0.5);\r\n        }\r\n        const value = Reflect.get(_uiMask, prop);\r\n        // 如果是放的话，可能要绑定原始实例上下文\r\n        return typeof value === 'function' ? value.bind(_uiMask) : value;\r\n        // return Reflect.get(_uiMask, prop)\r\n    },\r\n    set(target, p, newValue, receiver) {\r\n        if (p === 'active') {\r\n            _uiMask.active = newValue;\r\n            return true;\r\n        }\r\n        return Reflect.set(_uiMask, p, newValue, receiver);\r\n    }\r\n});\r\n// 接口隔离，实现具体的CcocosUIManager\r\nclass CcocosUIManager {\r\n    getTopView() {\r\n        return this.internalGetTopView();\r\n    }\r\n    open(viewType, args) {\r\n        let vt = viewType;\r\n        return this.internalOpen(vt, args);\r\n    }\r\n    close(viewortype, destory) {\r\n        this.internalClose(viewortype, destory);\r\n    }\r\n    openAndPush(viewType, group, args) {\r\n        let vt = viewType;\r\n        return this.internalOpenAndPush(vt, group, args);\r\n    }\r\n    closeAndPop(group, destroy) {\r\n        this.internalCloseAndPop(group, destroy);\r\n    }\r\n    clearStack(group, destroy) {\r\n        this.internalClearStack(group, destroy);\r\n    }\r\n}\r\nexport class UIManager extends CcocosUIManager {\r\n    constructor() {\r\n        super();\r\n        this._cache = new Map();\r\n        this._groupStacks = new Map();\r\n        UIMask.on(Node.EventType.TOUCH_END, (event) => {\r\n            let view = this.getTopView();\r\n            if ('__group__' in view) {\r\n                if (view.__group__ != undefined) {\r\n                    this.closeAndPop(view.__group__, false);\r\n                }\r\n                else {\r\n                    this.close(view, false);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    _getPrefabPath(viewType) {\r\n        let prototype = Object.getPrototypeOf(viewType);\r\n        // 沿着原型链向上查找直到找到定义__path__的基类。注意通过类只能找到静态属性。\r\n        while (prototype) {\r\n            if (prototype.hasOwnProperty('__path__')) {\r\n                return prototype.__path__;\r\n            }\r\n            prototype = Object.getPrototypeOf(prototype);\r\n        }\r\n        throw new Error(`Prefab path not found for ${viewType.constructor.name}`);\r\n    }\r\n    // 调整Mask层级\r\n    _adjustMaskLayer() {\r\n        let children = UIRoot.children;\r\n        if (children.length == 1) {\r\n            UIMask.active = false;\r\n            return;\r\n        }\r\n        UIMask.active = true;\r\n        UIMask.setSiblingIndex(Math.max(children.length - 2, 0));\r\n    }\r\n    _blockInput(block) {\r\n        function blocker(event) {\r\n            event.propagationImmediateStopped = true;\r\n        }\r\n        if (block) {\r\n            for (const eventType in Input.EventType) {\r\n                input.on(Input.EventType[eventType], blocker);\r\n            }\r\n        }\r\n        else {\r\n            for (const eventType in Input.EventType) {\r\n                input.off(Input.EventType[eventType], blocker);\r\n            }\r\n        }\r\n    }\r\n    _load(viewType, args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let target;\r\n            if (this._cache.has(viewType.name)) {\r\n                target = this._cache.get(viewType.name);\r\n            }\r\n            else {\r\n                let prefabPath = this._getPrefabPath(viewType);\r\n                const ResMgr = ServiceLocator.getService('ResLoader');\r\n                const prefab = yield ResMgr.loadPrefab(prefabPath);\r\n                target = instantiate(prefab);\r\n                this._cache.set(viewType.name, target);\r\n            }\r\n            return target.getComponent(viewType);\r\n        });\r\n    }\r\n    _remove(viewortype, destroy) {\r\n        var _a;\r\n        if (typeof viewortype == 'function') {\r\n            const cached = this._cache.get(viewortype.name);\r\n            if (!cached) {\r\n                console.warn(`No cached view found for ${viewortype.name}`);\r\n                return;\r\n            }\r\n            this._remove(cached.getComponent(viewortype), destroy);\r\n            return;\r\n        }\r\n        if ('__group__' in viewortype) {\r\n            viewortype.__group__ = undefined;\r\n        }\r\n        viewortype.onExit();\r\n        viewortype.node.removeFromParent();\r\n        if (destroy) {\r\n            let cacheKey = viewortype.constructor.name;\r\n            (_a = this._cache.get(cacheKey)) === null || _a === void 0 ? void 0 : _a.destroy();\r\n            this._cache.delete(cacheKey);\r\n        }\r\n    }\r\n    internalGetTopView() {\r\n        let target = UIRoot.children.reverse()[0];\r\n        if (!target) {\r\n            return undefined;\r\n        }\r\n        const comps = target.components;\r\n        for (let i = 0; i < comps.length; i++) {\r\n            const comp = comps[i];\r\n            if (\"__isIView__\" in comp) {\r\n                if (comp.__isIView__) {\r\n                    return comp;\r\n                }\r\n            }\r\n        }\r\n        console.warn(`No view found in ${target.name}`);\r\n        return undefined;\r\n    }\r\n    internalOpen(viewType, args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._blockInput(true);\r\n            let view = yield this._load(viewType, args);\r\n            addChild(view.node);\r\n            this._adjustMaskLayer();\r\n            view.onEnter(args);\r\n            this._blockInput(false);\r\n            return view;\r\n        });\r\n    }\r\n    internalClose(viewortype, destroy) {\r\n        this._remove(viewortype, destroy);\r\n        this._adjustMaskLayer();\r\n    }\r\n    internalOpenAndPush(viewType, group, args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this._blockInput(true);\r\n            let view = yield this._load(viewType, args);\r\n            let stack = this._groupStacks.get(group) || [];\r\n            this._groupStacks.set(group, stack);\r\n            let top = stack[stack.length - 1];\r\n            if (top) {\r\n                top.onPause();\r\n                top.node.removeFromParent();\r\n            }\r\n            if ('__group__' in view) {\r\n                view.__group__ = group;\r\n            }\r\n            stack.push(view);\r\n            addChild(view.node);\r\n            this._adjustMaskLayer();\r\n            view.onEnter(args);\r\n            this._blockInput(false);\r\n            return view;\r\n        });\r\n    }\r\n    internalCloseAndPop(group, destroy) {\r\n        let stack = this._groupStacks.get(group);\r\n        if (!stack) {\r\n            console.warn(`No stack found for group ${group}`);\r\n            return;\r\n        }\r\n        if (stack.length == 0) {\r\n            console.warn(`Stack is empty for group ${group}`);\r\n            return;\r\n        }\r\n        this._remove(stack.pop(), destroy);\r\n        let top = stack[stack.length - 1];\r\n        if (top) {\r\n            top.onResume();\r\n            addChild(top.node);\r\n        }\r\n        this._adjustMaskLayer();\r\n    }\r\n    internalClearStack(group, destroy) {\r\n        let stack = this._groupStacks.get(group);\r\n        if (!stack) {\r\n            console.warn(`No stack found for group ${group}`);\r\n            return;\r\n        }\r\n        while (stack.length > 0) {\r\n            let view = stack.pop();\r\n            if (view) {\r\n                this._remove(view, destroy);\r\n            }\r\n        }\r\n    }\r\n}\r\n","references":["/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/src/core/index.ts"],"dts":{"name":"/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/node_modules/.cache/rollup-plugin-typescript2/placeholder/libs/UIManager.d.ts","writeByteOrderMark":false,"text":"import { Component } from \"cc\";\r\nimport { IUIManager, IView } from \"@mflow/api\";\r\ntype ICocosView = IView & Component;\r\ndeclare abstract class CcocosUIManager implements IUIManager {\r\n    getTopView(): IView | undefined;\r\n    open<T extends IView>(viewType: new () => T, args?: any): Promise<T>;\r\n    close<T extends IView>(viewortype: T | (new () => T), destory?: boolean): void;\r\n    openAndPush<T extends IView>(viewType: new () => T, group: string, args?: any): Promise<T>;\r\n    closeAndPop(group: string, destroy?: boolean): void;\r\n    clearStack(group: string, destroy?: boolean): void;\r\n    protected abstract internalOpen<T extends ICocosView>(viewType: new () => T, args?: any): Promise<T>;\r\n    protected abstract internalClose<T extends ICocosView>(viewortype: T | (new () => T), destory?: boolean): void;\r\n    protected abstract internalOpenAndPush<T extends ICocosView>(viewType: new () => T, group: string, args?: any): Promise<T>;\r\n    protected abstract internalCloseAndPop(group: string, destroy?: boolean): void;\r\n    protected abstract internalClearStack(group: string, destroy?: boolean): void;\r\n    protected abstract internalGetTopView(): ICocosView | undefined;\r\n}\r\nexport declare class UIManager extends CcocosUIManager {\r\n    private _cache;\r\n    private _groupStacks;\r\n    constructor();\r\n    private _getPrefabPath;\r\n    private _adjustMaskLayer;\r\n    private _blockInput;\r\n    private _load;\r\n    private _remove;\r\n    protected internalGetTopView(): ICocosView | undefined;\r\n    protected internalOpen<T extends ICocosView>(viewType: new () => T, args?: any): Promise<T>;\r\n    protected internalClose<T extends ICocosView>(viewortype: T | (new () => T), destroy?: boolean): void;\r\n    protected internalOpenAndPush<T extends ICocosView>(viewType: new () => T, group: string, args?: any): Promise<T>;\r\n    protected internalCloseAndPop(group: string, destroy?: boolean): void;\r\n    protected internalClearStack(group: string, destroy?: boolean): void;\r\n}\r\nexport {};\r\n"}}
