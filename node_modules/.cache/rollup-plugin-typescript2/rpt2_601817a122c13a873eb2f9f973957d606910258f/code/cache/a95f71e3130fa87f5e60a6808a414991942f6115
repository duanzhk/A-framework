{"code":"import 'reflect-metadata';\r\nimport { getInterface, ServiceLocator } from \".\";\r\nclass Container {\r\n    constructor() {\r\n        this.ctor2ins = new Map(); // 使用构造函数作为键\r\n        this.symbol2ins = new Map();\r\n    }\r\n    regByCtor(type, ins) {\r\n        this.ctor2ins.set(type, ins);\r\n    }\r\n    getByCtor(type) {\r\n        const ins = this.ctor2ins.get(type);\r\n        if (!ins)\r\n            throw new Error(`${type.name} not registered!`);\r\n        return ins;\r\n    }\r\n    regBySymbol(ctor, ins) {\r\n        const sym = getInterface(ctor);\r\n        this.symbol2ins.set(sym, ins);\r\n    }\r\n    getBySymbol(sym) {\r\n        const ins = this.symbol2ins.get(sym);\r\n        if (!ins)\r\n            throw new Error(`${sym.toString()} not registered!`);\r\n        return ins;\r\n    }\r\n}\r\nexport class AbstractCore {\r\n    constructor() {\r\n        this.container = new Container();\r\n        this.initialize();\r\n    }\r\n    // 注册与获取模型\r\n    regModel(model) {\r\n        this.container.regByCtor(Object.getPrototypeOf(model).constructor, model);\r\n        model.initialize();\r\n    }\r\n    getModel(ctor) {\r\n        return this.container.getByCtor(ctor);\r\n    }\r\n    // 注册与获取管理器\r\n    regManager(manager) {\r\n        const ctor = Object.getPrototypeOf(manager).constructor;\r\n        this.container.regByCtor(ctor, manager);\r\n        this.container.regBySymbol(ctor, manager); // 同时注册Symbol\r\n        manager.initialize();\r\n    }\r\n    getManager(indent) {\r\n        if (typeof indent === 'symbol') {\r\n            return this.container.getBySymbol(indent);\r\n        }\r\n        else {\r\n            return this.container.getByCtor(indent);\r\n        }\r\n    }\r\n}\r\nexport class AbstractManager {\r\n    dispose() {\r\n        this.releaseEventManager();\r\n    }\r\n    getModel(ctor) {\r\n        // 保持框架独立性，不与具体应用入口(app类)耦合\r\n        // 框架高内聚，使用ServiceLocator获取core\r\n        return ServiceLocator.getService('core').getModel(ctor);\r\n    }\r\n    // 事件管理器获取（通过服务定位器解耦）\r\n    getEventManager() {\r\n        if (!this.eventManager) {\r\n            this.eventManager = ServiceLocator.getService('EventManager');\r\n        }\r\n        return this.eventManager;\r\n    }\r\n    releaseEventManager() {\r\n        var _a, _b;\r\n        if (this.eventManager) {\r\n            // 假设 IEventManager 有销毁逻辑（如第三方库）\r\n            (_b = (_a = this.eventManager) === null || _a === void 0 ? void 0 : _a.dispose) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n            this.eventManager = undefined;\r\n        }\r\n    }\r\n}\r\n","references":["/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/node_modules/reflect-metadata/index.d.ts","/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/src/core/index.ts"],"dts":{"name":"/Users/dzk/Documents/git-projects/cocos-modular-flow-framework/node_modules/.cache/rollup-plugin-typescript2/placeholder/core/Core.d.ts","writeByteOrderMark":false,"text":"import 'reflect-metadata';\r\nimport { ICore, IEventManager, IManager, IModel } from \".\";\r\nexport declare abstract class AbstractCore<T extends AbstractCore<T>> implements ICore {\r\n    private readonly container;\r\n    constructor();\r\n    protected abstract initialize(): void;\r\n    regModel<T extends IModel>(model: T): void;\r\n    getModel<T extends IModel>(ctor: new () => T): T;\r\n    regManager<T extends IManager>(manager: T): void;\r\n    getManager<T extends IManager>(indent: (new () => T) | symbol): T;\r\n}\r\nexport declare abstract class AbstractManager implements IManager {\r\n    private eventManager?;\r\n    abstract initialize(): void;\r\n    dispose(): void;\r\n    protected getModel<T extends IModel>(ctor: new () => T): T;\r\n    protected getEventManager(): IEventManager;\r\n    private releaseEventManager;\r\n}\r\n"}}
